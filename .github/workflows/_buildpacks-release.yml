name: _buildpacks-release

on:
  workflow_call:
    inputs:
      app_id:
        description: Application ID of GitHub application (e.g.; the Linguist App)
        type: string
        required: true
      app_email:
        description: The email address of the GitHub application bot user (e.g.; the Linguist App)
        type: string
        required: false
        default: ${{ vars.LINGUIST_GH_APP_EMAIL }}
      app_username:
        description: The username of the GitHub application bot user (e.g.; the Linguist App)
        type: string
        required: false
        default: ${{ vars.LINGUIST_GH_APP_USERNAME }}
      dry_run:
        required: false
        type: boolean
        default: false
        description: Flag used for testing purposes to prevent actions that perform publishing operations from executing
      ip_allowlisted_runner:
        description: The GitHub Actions runner to use to run jobs that require IP allow-list privileges
        type: string
        required: false
        default: pub-hk-ubuntu-22.04-small
      languages_cli_branch:
        description: The branch to install the Languages CLI from (FOR TESTING)
        type: string
        required: false
        default: main
      target:
        description: Target Architectures to build
        type: string
        required: false
        default: 'x86_64-unknown-linux-gnu'
    secrets:
      app_private_key:
        description: Private key of GitHub application (e.g. the Linguist App)
        required: true
      cnb_registry_token:
        required: true
        description: The token of the GitHub user used to interact with the CNB registry
      docker_hub_user:
        required: true
        description: The username to login to Docker Hub with
      docker_hub_token:
        required: true
        description: The token to login to Docker Hub with

defaults:
  run:
    # Setting an explicit bash shell ensures GitHub Actions enables pipefail mode too,
    # ratherthan only error on exit (improving failure UX when pipes are used). See:
    # https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsshell
    shell: bash

env:
  CARGO_TERM_COLOR: always

jobs:
  compile:
    name: Compile Buildpacks
    runs-on: ${{ inputs.ip_allowlisted_runner }}
    outputs:
      buildpacks: ${{ steps.generate-buildpack-matrix.outputs.buildpacks }}
      version: ${{ steps.generate-buildpack-matrix.outputs.version }}
      changelog: ${{ steps.generate-changelog.outputs.changelog }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Install musl-tools
        if: inputs.target == 'x86_64-unknown-linux-gnu'
        run: sudo apt-get install musl-tools --no-install-recommends

      - name: Install aarch64 musl-tools
        if: inputs.target == 'aarch64-unknown-linux-gnu'
        run: sudo apt-get install g++-aarch64-linux-gnu libc6-dev-arm64-cross --no-install-recommends

      - name: Update Rust toolchain
        run: rustup update

      - name: Install Rust linux-musl target
        if: inputs.target == 'x86_64-unknown-linux-gnu'
        run: rustup target add x86_64-unknown-linux-musl

      - name: Install Rust aarch64-musl target
        if: inputs.target == 'aarch64-unknown-linux-gnu'
        run: rustup target add aarch64-unknown-linux-gnu

      - name: Rust cache
        uses: Swatinem/rust-cache@v2.7.0

      # the version of `libcnb-cargo` installed here is kept in sync with the version of `libcnb-package`
      # that the release automation CLI tooling depends on
      - name: Install libcnb-cargo
        run: |
          LOCKFILE_URL="https://raw.githubusercontent.com/heroku/languages-github-actions/${{ inputs.languages_cli_branch }}/Cargo.lock"
          LIBCNB_PACKAGE_VERSION=$( \
            curl --silent --show-error --fail --retry 5 --retry-all-errors --connect-timeout 10 --max-time 60 "${LOCKFILE_URL}" \
            | yq -ptoml -oyaml '.package[] | select(.name == "libcnb-package") | .version' \
          )
          cargo install --locked "libcnb-cargo@${LIBCNB_PACKAGE_VERSION}"

      - name: Install Languages CLI
        uses: heroku/languages-github-actions/.github/actions/install-languages-cli@main
        with:
          branch: ${{ inputs.languages_cli_branch }}
          update_rust_toolchain: false

      - name: Package buildpacks
        id: libcnb-package
        run: cargo libcnb package --release --target ${{ inputs.target }}

      - name: Generate buildpack matrix
        id: generate-buildpack-matrix
        run: actions generate-buildpack-matrix

      - name: Generate changelog
        id: generate-changelog
        run: actions generate-changelog --version ${{ steps.generate-buildpack-matrix.outputs.version }}

      - name: Temporary fix for bash-based buildpacks
        run: |
          buildpacks='${{ steps.generate-buildpack-matrix.outputs.buildpacks }}'

          bash_buildpack_source_dirs=()
          bash_buildpack_output_dirs=()

          # copy any bash-based buildpack to target buildpack dir because `cargo libcnb package` will ignore them
          for buildpack in $(jq --exit-status -c '.[]' <<< "${buildpacks}"); do
            buildpack_dir=$(jq --exit-status -r '.buildpack_dir' <<< "${buildpack}")
            output_dir=$(jq --exit-status -r '.buildpack_output_dir' <<< "${buildpack}")
            if [ ! -d "${output_dir}" ]; then
              echo "bash-based buildpack detected at ${buildpack_dir}"
              cp -R "${buildpack_dir}" "${output_dir}"
              bash_buildpack_source_dirs+=("${buildpack_dir}")
              bash_buildpack_output_dirs+=("${output_dir}")
            fi
          done

          # replace dependencies that reference a bash-buildpack
          for buildpack in $(jq --exit-status -c '.[]' <<< "${buildpacks}"); do
            output_dir=$(jq --exit-status -r '.buildpack_output_dir' <<< "${buildpack}")
            echo "checking dependencies in ${output_dir}/package.toml"
            for dep in $(yq -oy '.dependencies[].uri' "${output_dir}/package.toml"); do
              if realpath "${dep}" &> /dev/null; then
                dep_path=$(realpath "${dep}")
                for i in "${!bash_buildpack_source_dirs[@]}"; do
                  bash_buildpack_source_dir="${bash_buildpack_source_dirs[$i]}"
                  bash_buildpack_output_dir="${bash_buildpack_output_dirs[$i]}"
                  if [ "${bash_buildpack_source_dir}" = "${dep_path}" ]; then
                    echo "replacing ${dep} with ${bash_buildpack_output_dir}"
                    sed -i 's|'"$dep"'|'"$bash_buildpack_output_dir"'|g' "${output_dir}/package.toml"
                  fi
                done
              fi
            done
          done

      - name: Cache buildpacks
        uses: actions/cache/save@v3
        with:
          key: ${{ github.run_id }}-compiled-buildpacks
          path: target/buildpack

  publish-github:
    name: Publish â†’ GitHub Release
    needs: [compile]
    runs-on: ${{ inputs.ip_allowlisted_runner }}
    steps:
      - name: Restore buildpacks
        uses: actions/cache/restore@v3
        with:
          fail-on-cache-miss: true
          key: ${{ github.run_id }}-compiled-buildpacks
          path: target/buildpack
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 1

      - name: Install Pack CLI
        uses: buildpacks/github-actions/setup-pack@v5.4.0

      - name: Generate CNB files
        run: |
          for buildpack in $(jq --exit-status -c '.[]' <<< '${{ needs.compile.outputs.buildpacks }}'); do
            artifact_prefix=$(jq --exit-status -r '.buildpack_artifact_prefix' <<< "${buildpack}")-${{ inputs.target }}
            output_dir=$(jq --exit-status -r '.buildpack_output_dir' <<< "${buildpack}")
            pack buildpack package "${artifact_prefix}.cnb" --config "${output_dir}/package.toml" --format file --verbose
          done

      - name: Get token for GitHub application (Linguist)
        uses: heroku/use-app-token-action@main
        id: generate-token
        with:
          app_id: ${{ inputs.app_id }}
          private_key: ${{ secrets.app_private_key }}

      - name: Check if release exists
        id: check
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.app_token }}
        run: echo "published_to_github=$(gh release view v${{ needs.compile.outputs.version }} -R ${{ github.repository }} &> /dev/null && echo "true" || echo "false")" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        if: inputs.dry_run == false && steps.check.outputs.published_to_github == 'false'
        uses: softprops/action-gh-release@v0.1.15
        with:
          token: ${{ steps.generate-token.outputs.app_token }}
          tag_name: v${{ needs.compile.outputs.version }}
          body: ${{ needs.compile.outputs.changelog }}
          files: "*.cnb"
          fail_on_unmatched_files: true
